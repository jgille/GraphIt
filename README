== GraphIt ==

Author: Jon Ivmark
Date: 2012-06-06
Licence: Apache License, Version 2.0 (http://www.apache.org/licenses/LICENSE-2.0)
Requries: Java SDK 6+


1. Description
===============================================================================================

GraphIt is an easy to use, fast, RAM only (or mostly) property graph
database. It implements the Blueprints interfaces
(https://github.com/tinkerpop/blueprints/wiki/), thereby supporting
advanced ad-hoc traversals using Gremlin
(https://github.com/tinkerpop/gremlin/wiki).

By default, all data is stored in memory (optionally dumped to
disk/restored from disk on graph shutdown and init). However, the
repositories used by the graph are pluggable so you are free to write
your own repo(s). For instance, you might want to keep all graph
primitives, i.e. node ids and relations (edge primitives), but keep
properties in a key value store. This is accomplished by using custom
PropertiesRepository instances for the graph, for instance with: graph.setNodePropertiesRepo(myCustomRepo);

2. Installation
===============================================================================================

Build from the root directory using:

mvn install -DskiptTests

3. Usage
===============================================================================================

An example:

    public static void main(String[] args) {
        final PropertyGraph graph = new PropertyGraphImpl("e-store");

        // Create some metadata
        NodeType user = graph.getOrCreateNodeType("user");
        NodeType item = graph.getOrCreateNodeType("item");

        final EdgeType bought = graph.getOrCreateEdgeType("bought");
        EdgeType viewed = graph.getOrCreateEdgeType("viewed");

        // Add some nodes, with properties
        Node u1 = graph.addNode(new NodeId(user, "u1"));
        u1.setProperty("name", "John Doe");
        graph.setNodeProperties(u1.getNodeId(), u1);

        Node i1 = graph.addNode(new NodeId(item, "i1"));
        i1.setProperty("price", 200.0);
        i1.setProperty("name", "Playstation II");

        final Node i2 = graph.addNode(new NodeId(item, "i2"));
        i2.setProperty("price", 899.90);
        i2.setProperty("name", "MacBook Pro");
        i2.setProperty("categories", Arrays.asList("Rather expensive computer", "Laptop"));

        // Add some edges, that can also have properties
        Edge v1 = graph.addEdge(u1.getNodeId(), i1.getNodeId(), viewed);
        v1.setProperty("date", new Date());
        graph.setEdgeProperties(v1.getEdgeId(), v1);

        Edge b1 = graph.addEdge(u1.getNodeId(), i2.getNodeId(), bought);
        b1.setProperty("date", new Date());
        graph.setEdgeProperties(b1.getEdgeId(), b1);

        // Get all items that user u1 has viewed
        List<Node> viewedItems =
            graph.getNeighbors(u1.getNodeId(), viewed, EdgeDirection.OUTGOING).asList();

        // Get the first item that user u1 has viewed, transformed to just the
        // product name
        List<String> viewedItemName =
            graph.getNeighbors(u1.getNodeId(), viewed, EdgeDirection.OUTGOING)
                .head(1)
                .transform(new Function<Node, String>() {

                    @Override
                    public String apply(Node node) {
                        return (String) node.getProperty("name");
                    }
                })
                .asList();

        // Get all purchases of item i1 that took place within the last hour
        Iterable<Edge> purchases =
            graph.getEdges(i1.getNodeId(), bought, EdgeDirection.INCOMING)
                .filter(new Predicate<Edge>() {

                    @Override
                    public boolean apply(Edge purchase) {
                        Date when = (Date) purchase.getProperty("date");
                        return when != null
                            && System.currentTimeMillis() - when.getTime() < 60 * 60 * 1000l;
                    }
                });
        // Note that graph iteration is done lazily, so no purchases have been
        // retrieved yet
        // (they will be once you start iterating them/calling toList etc).

        // Get an item recommendation using collaborative filtering
        Counter<Node> purchasedItems =
            // Get all users that bough i2
            graph.getNeighbors(i2.getNodeId(), bought, EdgeDirection.INCOMING)
                // Get all the items these users bought
                .transform(new Function<Node, Iterable<Node>>() {

                    @Override
                    public Iterable<Node> apply(Node node) {
                        return graph.getNeighbors(node.getNodeId(), bought, EdgeDirection.OUTGOING)
                            // filter out i2
                            .filter(new Predicate<Node>() {

                                @Override
                                public boolean apply(Node input) {
                                    return !input.getNodeId().equals(i2.getNodeId());
                                }
                            });
                    }
                })
                // Concatenate these and make a frequency count of all items
                .mapReduce(new ConcatMapper<Node>(),
                           new CounterReducer<Node>());
        // Get the recommendation
        Iterable<CountedElement<Node>> recommendedItems =
            purchasedItems.iterable(SortOrder.DESCENDING);
    }

4. Dependencies
===============================================================================================

All required third party libraries are included in the project jar file.
